модель политики доступа


policy_on: str
action: str
special_users: list[ids]
awailable_fields_to_interact: list[str]
disabled_fields_to_interact: list[str]
response_hidden_fields: list[str]
allowed_for_spaces: list[int]
conditions: list[str]




проверки должны возвращать состояния, а не True/False
статусы
    ALLOWED                    - 
    DENIED                     - запрещено
    ALLOWED_NO_OTHER_conditions    - разрешает без дальнейших проверок (в том числе проверок других политик) (проверки с таким возможным статусом должны быть выполнены в первую очередь)



Примеры


пример политики на любое действие, для специальных пользователей. Таким образом мы можем создать суперпользователей
dict(
    policy_on   =   *                                                  # политика на любой контроллер
    policy_data =   dict(
        action                        =   *
        special_users                 =   [1, 151]
        awailable_fields_to_interact  =   *
    )
    conditions = [
        is_special_user
    ]
)



пример гранулированной политики на создание ноды
dict(
    policy_on   =   nodes
    policy_data =   dict(
        action                         =   create                       # имя действия (совпадает с именем контроллера)
        object_id                      =   1                            # 
        special_users                  =   [1, 2, 3, 4, 5]              # пользователи, для которых не нужно выполнять проверки
        allowed_for_spaces             =   [5, 6. 7]
        awailable_fields_to_interact   =   [documents, title]
        disabled_fields_to_interact    =   []                           # нужно указать disabled_fields_for_filling, либо awailable_fields_for_filling, в противном случае будут доступны все поля
        response_hidden_fields         =   []                           # какие поля пользователь не может видеть
    )
    conditions  = [                                                     # в проверку аргументом идёт policy_data, caller и dto
        is_on_object,
        is_from_allowed_space,
        is_special_user,
    ]
)



пример гранулированной политики на спейсы пользователя
dict(
    policy_on   =   nodes
    policy_data =   dict(
        action                         =   create                       # имя действия (совпадает с именем контроллера)
        object_id                      =   1                            # 
        special_users                  =   [1, 2, 3, 4, 5]              # пользователи, для которых не нужно выполнять проверки
        allowed_for_spaces             =   USER_SPACES
        awailable_fields_to_interact   =   [documents, title]
        disabled_fields_to_interact    =   []                           # нужно указать disabled_fields_for_filling, либо awailable_fields_for_filling, в противном случае будут доступны все поля
        response_hidden_fields         =   []                           # какие поля пользователь не может видеть
    )
    conditions  = [                                                         # в проверку аргументом идёт policy_data, caller и dto
        is_on_object,
        is_from_allowed_space,
        is_special_user,        
    ]
)




пример политики разрешающей изменение определённых полей для пользователей




находим все политики у которых
# (
# пользователь лежит в special_users OR
# пространство пользователя лежит в allowed_for_spaces
# )
# AND



# политики для специальных пользователей (там где мы есть)
# политика определена на конкретное действие
(
policy_on совпадает с именем контроллера, чей метод был вызван
action совпадает с именем метода контроллера, чей метод был вызван
)


по всем отобранным объектам запускаем проверки, оставляем только подходящие объекты







1. находим все политики ресурса на конкретного пользователя
   ...

2. эффективно выполняем все проверки на которые ссылается политика
   ВАРИАНТ А
    микросерсис ресурсов ходит по апишке на уровне мидлвера авторизации в систему доступов.
    передаёт caller, dto, dm, policy_on, action

    проверки написаны на go, система доступов является отдельной системой,
    она работает в асинхронном режиме и ходит в slave базы (она ничего не пишет, только читает),
    Получеи надлежащие политики доступа в зависимости от запроса 
    далее отфильтровывает их на уровне application и возвращает список объектов над которыми можно производить действие
    асимптотика O(n*n*k), где k - общая сложность всех проверок, которые потребуется запустить.
    В худшем случае k равно кол-ву проверок, зарегистрированных в системе

   ВАРИАНТ B
    проверки написаны на python, автоматически транспилируются в C++ при помощи py2cpp
    со стороны функции на плюсах итерируем все подходящие политики,
    запускаем транспилированные функции conditions
    
   ВАРИАНТ Б
    проверки написаны на cython, кладём их в conditions.pyx в каждом модуле




вопросы
проверка на разрешение действия действительно должна быть на контроллер, 
либо это должна быть логика над вызовом метода сервиса ?
